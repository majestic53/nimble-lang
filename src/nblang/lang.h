/*
 * lang.h
 * Copyright (C) 2013 David Jolly
 * ----------------------
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef LANG_H_
#define LANG_H_

#include <set>
#include <string>
#include <vector>

/*
 * Language types
 */
enum {
	ACCESS_TYPE_GLOBAL = 0,
};

enum {
	ARGUMENT_TYPE_ARG = 0,
	ARGUMENT_TYPE_ARG_COUNT,
};

enum {
	ASSIGNMENT_TYPE_VAR_SET = 0,
};

enum {
	BINARY_OPERATOR_TYPE_AND = 0,
	BINARY_OPERATOR_TYPE_OR,
	BINARY_OPERATOR_TYPE_XOR,
};

enum {
	CALL_TOKEN_TYPE_CALL = 0,
};

enum {
	CLASS_TOKEN_TYPE_BEGIN = 0,
	CLASS_TOKEN_TYPE_COMPOUND_ASSIGNMENT,
	CLASS_TOKEN_TYPE_CONDITIONAL_SEPERATOR_LIST,
	CLASS_TOKEN_TYPE_CONDITIONAL_STATEMENT,
	CLASS_TOKEN_TYPE_CONDITIONAL_STATEMENT_LIST,
	CLASS_TOKEN_TYPE_END,
	CLASS_TOKEN_TYPE_EXPRESSION,
	CLASS_TOKEN_TYPE_EXPRESSION_LIST,
	CLASS_TOKEN_TYPE_EXPRESSION_PARAMETER_LIST,
	CLASS_TOKEN_TYPE_FILE_STREAM_LIST,
	CLASS_TOKEN_TYPE_FUNCTION_ASSIGNMENT,
	CLASS_TOKEN_TYPE_FUNCTION_PARAMETER_LIST,
	CLASS_TOKEN_TYPE_IDENTIFIER_LIST,
	CLASS_TOKEN_TYPE_IDENTIFIER_PARAMETER_LIST,
	CLASS_TOKEN_TYPE_LIST_INDEX,
	CLASS_TOKEN_TYPE_RANGE_STATEMENT,
	CLASS_TOKEN_TYPE_SIMPLE_ASSIGNMENT,
	CLASS_TOKEN_TYPE_STATEMENT,
	CLASS_TOKEN_TYPE_STATEMENT_LIST,
	CLASS_TOKEN_TYPE_STREAM_STATEMENT,
	CLASS_TOKEN_TYPE_TOKEN,
};

enum {
	COMPARATOR_TYPE_AND = 0,
	COMPARATOR_TYPE_EQUAL,
	COMPARATOR_TYPE_GREATER,
	COMPARATOR_TYPE_GREATER_EQUAL,
	COMPARATOR_TYPE_LESSER,
	COMPARATOR_TYPE_LESSER_EQUAL,
	COMPARATOR_TYPE_OR,
	COMPARATOR_TYPE_NOT_EQUAL,
};

enum {
	CONDITIONAL_SEPERATOR_AND = 0,
	CONDITIONAL_SEPERATOR_OR,
};

enum {
	CONDITIONAL_TYPE_IF = 0,
	CONDITIONAL_TYPE_IFELSE,
	CONDITIONAL_TYPE_RANGE,
	CONDITIONAL_TYPE_WHILE,
	CONDITIONAL_TYPE_UNTIL,
};

enum {
	CONSTANT_TYPE_EMPTY = 0,
	CONSTANT_TYPE_ENDLINE,
	CONSTANT_TYPE_FALSE,
	CONSTANT_TYPE_NULL,
	CONSTANT_TYPE_TRUE,
};

enum {
	CONTROL_TYPE_BREAK = 0,
	CONTROL_TYPE_CONTINUE,
	CONTROL_TYPE_EXIT,
};

enum {
	CONVERSION_OPERATOR_TYPE_INT = 0,
	CONVERSION_OPERATOR_TYPE_FLOAT,
};

enum {
	FILE_STREAM_OPERATOR_TYPE_APPEND = 0,
	FILE_STREAM_OPERATOR_TYPE_BIN,
	FILE_STREAM_OPERATOR_TYPE_TRUNC,
};

enum {
	IO_OPERATOR_TYPE_EXECUTE = 0,
	IO_OPERATOR_TYPE_IN,
	IO_OPERATOR_TYPE_OUT,
};

enum {
	IN_LIST_OPERATOR_TYPE_PUSH_END = 0,
	IN_LIST_OPERATOR_TYPE_PUSH_FRONT,
};

enum {
	ITERATOR_OPERATOR_TYPE_POST_DECREMENT = 0,
	ITERATOR_OPERATOR_TYPE_POST_INCREMENT,
	ITERATOR_OPERATOR_TYPE_PRE_DECREMENT,
	ITERATOR_OPERATOR_TYPE_PRE_INCREMENT,
};

enum {
	LOGICAL_OPERATOR_TYPE_CEILING = 0,
	LOGICAL_OPERATOR_TYPE_FLOOR,
	LOGICAL_OPERATOR_TYPE_ROUND,
	LOGICAL_OPERATOR_TYPE_SHIFT_LEFT,
	LOGICAL_OPERATOR_TYPE_SHIFT_RIGHT,
};

enum {
	OUT_LIST_OPERATOR_TYPE_POP_END = 0,
	OUT_LIST_OPERATOR_TYPE_POP_FRONT,
	OUT_LIST_OPERATOR_TYPE_SIZE,
};

enum {
	STREAM_TYPE_FILE = 0,
	STREAM_TYPE_STDIN,
	STREAM_TYPE_STDOUT,
};

enum {
	SYMBOL_TYPE_ARITHMETIC_ADD = 0,
	SYMBOL_TYPE_ARITHMETIC_DIVIDE,
	SYMBOL_TYPE_ARITHMETIC_SUBTRACT,
	SYMBOL_TYPE_ARITHMETIC_MODULUS,
	SYMBOL_TYPE_ARITHMETIC_MULTIPLY,
	SYMBOL_TYPE_COMPARATOR,
	SYMBOL_TYPE_CLOSE_CURLY_BRACE,
	SYMBOL_TYPE_CLOSE_BRACE,
	SYMBOL_TYPE_CLOSE_PARENTHESIS,
	SYMBOL_TYPE_LIST_SEPERATOR,
	SYMBOL_TYPE_OPEN_CURLY_BRACE,
	SYMBOL_TYPE_OPEN_BRACE,
	SYMBOL_TYPE_OPEN_PARENTHESIS,
	SYMBOL_TYPE_STATEMENT_SEPERATOR,
	SYMBOL_TYPE_TERMINATOR,
	SYMBOL_TYPE_UNARY_NEGATION,
};

enum {
	TOKEN_TYPE_ACCESS = 0,
	TOKEN_TYPE_ARGUMENT,
	TOKEN_TYPE_ASSIGNMENT,
	TOKEN_TYPE_BINARY_OPERATOR,
	TOKEN_TYPE_CALL,
	TOKEN_TYPE_COMPARATOR,
	TOKEN_TYPE_CONDITIONAL,
	TOKEN_TYPE_CONDITIONAL_SEPERATOR,
	TOKEN_TYPE_CONSTANT,
	TOKEN_TYPE_CONTROL,
	TOKEN_TYPE_CONVERSION_OPERATOR,
	TOKEN_TYPE_FILE_STREAM_OPERATOR,
	TOKEN_TYPE_FLOAT,
	TOKEN_TYPE_IDENTIFIER,
	TOKEN_TYPE_IO_OPERATOR,
	TOKEN_TYPE_IN_LIST_OPERATOR,
	TOKEN_TYPE_INTEGER,
	TOKEN_TYPE_ITERATOR_OPERATOR,
	TOKEN_TYPE_LOGICAL_OPERATOR,
	TOKEN_TYPE_OUT_LIST_OPERATOR,
	TOKEN_TYPE_VAR_STRING,
	TOKEN_TYPE_STREAM,
	TOKEN_TYPE_SYMBOL,
	TOKEN_TYPE_USING,
};

enum {
	USING_TYPE_USE = 0,
};

/*
 * Max language values
 */
#define MAX_ACCESS_TYPE ACCESS_TYPE_GLOBAL
#define MAX_ARGUMENT_TYPE ARGUMENT_TYPE_ARG_COUNT
#define MAX_ASSIGNMENT_TYPE ASSIGNMENT_TYPE_VAR_SET
#define MAX_BINARY_OPERATOR_TYPE BINARY_OPERATOR_TYPE_XOR
#define MAX_CALL_TYPE CALL_TOKEN_TYPE_CALL
#define MAX_CLASS_TOK_TYPE CLASS_TOKEN_TYPE_TOKEN
#define MAX_COMPARATOR_TYPE COMPARATOR_TYPE_NOT_EQUAL
#define MAX_CONDITIONAL_SEPERATOR_TYPE CONDITIONAL_SEPERATOR_OR
#define MAX_CONDITIONAL_TYPE CONDITIONAL_TYPE_UNTIL
#define MAX_CONSTANT_TYPE CONSTANT_TYPE_TRUE
#define MAX_CONTROL_TYPE CONTROL_TYPE_EXIT
#define MAX_CONVERSION_OPERATOR_TYPE CONVERSION_OPERATOR_TYPE_FLOAT
#define MAX_FILE_STREAM_OPERATOR_TYPE FILE_STREAM_OPERATOR_TYPE_TRUNC
#define MAX_IO_OPERATOR_TYPE IO_OPERATOR_TYPE_OUT
#define MAX_IN_LIST_OPERATOR_TYPE IN_LIST_OPERATOR_TYPE_PUSH_FRONT
#define MAX_ITERATOR_OPERATOR_TYPE ITERATOR_OPERATOR_TYPE_PRE_INCREMENT
#define MAX_LOGICAL_OPERATOR_TYPE LOGICAL_OPERATOR_TYPE_SHIFT_RIGHT
#define MAX_OUT_LIST_OPERATOR_TYPE OUT_LIST_OPERATOR_TYPE_SIZE
#define MAX_STREAM_TYPE STREAM_TYPE_STDOUT
#define MAX_SYMBOL_TYPE SYMBOL_TYPE_UNARY_NEGATION
#define MAX_TOKEN_TYPE TOKEN_TYPE_USING
#define MAX_USING_TYPE USING_TYPE_USE
#define MAX_LOOKUP_TYPE TOKEN_TYPE_USING

/*
 * Language strings
 */
static const std::string ACCESS_TYPE_STR[] = {
	"glob",
};

static const std::string ARGUMENT_TYPE_STR[] = {
	"arg", "args",
};

static const std::string ASSIGNMENT_TYPE_STR[] = {
	"set",
};

static const std::string BINARY_OPERATOR_TYPE_STR[] = {
	"band", "bor", "bxor",
};

static const std::string CALL_TYPE_STR[] = {
	"call",
};

static const std::string CLASS_TOK_TYPE_STR[] = {
	"begin", "compound assignment", "conditional seperator list", "conditional statement", "conditional statement list", "end", "expression", "expression list", 
	"expression parameter list", "file stream list", "function assignment", "function parameter list", "identifier list", "identifier parameter list", "list index", "range statement", 
	"simple assignment", "statement", "statement list", "stream statement", "token",
};

static const std::string COMPARATOR_TYPE_STR[] = {
	"and", "eq", "gt", "gte", "lt", "lte", "or", "neq",
};

static const std::string CONDITIONAL_SEPERATOR_TYPE_STR[] = {
	"land", "lor",
};

static const std::string CONDITIONAL_TYPE_STR[] = {
	"if", "ifelse", "range", "while", "until",
};

static const std::string CONSTANT_TYPE_STR[] = {
	"empty", "endl", "false", "null", "true",
};

static const std::string CONTROL_TYPE_STR[] = {
	"break", "continue", "exit",
};

static const std::string CONVERSION_OPERATOR_TYPE_STR[] = {
	"int", "float",
};

static const std::string FILE_STREAM_OPERATOR_TYPE_STR[] = {
	"append", "bin", "trunc",
};

static const std::string IO_OPERATOR_TYPE_STR[] = {
	"exec", "in", "out",
};

static const std::string IN_LIST_OPERATOR_TYPE_STR[] = {
	"lpush", "fpush",
};

static const std::string ITERATOR_OPERATOR_TYPE_STR[] = {
	"posd", "posi", "pred", "prei",
};

static const std::string LOGICAL_OPERATOR_TYPE_STR[] = {
	"ceil", "flr", "rnd", "shl", "shr",
};

static const std::string OUT_LIST_OPERATOR_TYPE_STR[] = {
	"lpop", "fpop", "size",
};

static const std::string STREAM_TYPE_STR[] = {
	"file", "stdin", "stdout",
};

static const std::string SYMBOL_TYPE_STR[] = {
	"+", "/", "-", "%", "*", "?", "}", "]",
	")", ",", "{", "[", "(", ":", ";", "~",
};

static const std::string TOKEN_TYPE_STR[] = {
	"access", "argument", "assignment", "binary", "call", "comparator", "conditional", "conditional seperator", "constant", "control", 
	"conversion", "file stream", "float", "identifier", "io", "in list", "integer", "iterator", "logical", 
	"out list", "string", "stream", "symbol", "using",
};

static const std::string USING_TYPE_STR[] = {
	"use",
};

/*
 * Language string lookup tables
 */
static const size_t TYPE_COUNT_LOOKUP[] = {
	MAX_ACCESS_TYPE,
	MAX_ARGUMENT_TYPE,
	MAX_ASSIGNMENT_TYPE,
	MAX_BINARY_OPERATOR_TYPE,
	MAX_CALL_TYPE,
	MAX_COMPARATOR_TYPE,
	MAX_CONDITIONAL_TYPE,
	MAX_CONDITIONAL_SEPERATOR_TYPE,
	MAX_CONSTANT_TYPE,
	MAX_CONTROL_TYPE,
	MAX_CONVERSION_OPERATOR_TYPE,
	MAX_FILE_STREAM_OPERATOR_TYPE,
	0,
	0,
	MAX_IO_OPERATOR_TYPE,
	MAX_IN_LIST_OPERATOR_TYPE,
	0,
	MAX_ITERATOR_OPERATOR_TYPE,
	MAX_LOGICAL_OPERATOR_TYPE,
	MAX_OUT_LIST_OPERATOR_TYPE,
	0,
	MAX_STREAM_TYPE,
	MAX_SYMBOL_TYPE,
	MAX_USING_TYPE,
};

static const std::string *TYPE_STRING_LOOKUP[] = {
	ACCESS_TYPE_STR,
	ARGUMENT_TYPE_STR,
	ASSIGNMENT_TYPE_STR,
	BINARY_OPERATOR_TYPE_STR,
	CALL_TYPE_STR,
	COMPARATOR_TYPE_STR,
	CONDITIONAL_TYPE_STR,
	CONDITIONAL_SEPERATOR_TYPE_STR,
	CONSTANT_TYPE_STR,
	CONTROL_TYPE_STR,
	CONVERSION_OPERATOR_TYPE_STR,
	FILE_STREAM_OPERATOR_TYPE_STR,
	NULL,
	NULL,
	IO_OPERATOR_TYPE_STR,
	IN_LIST_OPERATOR_TYPE_STR,
	NULL,
	ITERATOR_OPERATOR_TYPE_STR,
	LOGICAL_OPERATOR_TYPE_STR,
	OUT_LIST_OPERATOR_TYPE_STR,
	NULL,
	STREAM_TYPE_STR,
	SYMBOL_TYPE_STR,
	USING_TYPE_STR,
};

/*
 * Language string sets
 */
static const std::set<std::string> ACCESS_TYPE_SET(
	ACCESS_TYPE_STR,
	ACCESS_TYPE_STR + MAX_ACCESS_TYPE + 1
	);

static const std::set<std::string> ARGUMENT_TYPE_SET(
	ARGUMENT_TYPE_STR,
	ARGUMENT_TYPE_STR + MAX_ARGUMENT_TYPE + 1
	);

static const std::set<std::string> ASSIGNMENT_TYPE_SET(
	ASSIGNMENT_TYPE_STR,
	ASSIGNMENT_TYPE_STR + MAX_ASSIGNMENT_TYPE + 1
	);

static const std::set<std::string> BINARY_OPERATOR_TYPE_SET(
	BINARY_OPERATOR_TYPE_STR,
	BINARY_OPERATOR_TYPE_STR + MAX_BINARY_OPERATOR_TYPE + 1
	);

static const std::set<std::string> CALL_TYPE_SET(
	CALL_TYPE_STR,
	CALL_TYPE_STR + MAX_CALL_TYPE + 1
	);

static const std::set<std::string> COMPARATOR_TYPE_SET(
	COMPARATOR_TYPE_STR,
	COMPARATOR_TYPE_STR + MAX_COMPARATOR_TYPE + 1
	);

static const std::set<std::string> CONDITIONAL_SEPERATOR_TYPE_SET(
	CONDITIONAL_SEPERATOR_TYPE_STR,
	CONDITIONAL_SEPERATOR_TYPE_STR + MAX_CONDITIONAL_SEPERATOR_TYPE + 1
	);

static const std::set<std::string> CONDITIONAL_TYPE_SET(
	CONDITIONAL_TYPE_STR,
	CONDITIONAL_TYPE_STR + MAX_CONDITIONAL_TYPE + 1
	);

static const std::set<std::string> CONSTANT_TYPE_SET(
	CONSTANT_TYPE_STR,
	CONSTANT_TYPE_STR + MAX_CONSTANT_TYPE + 1
	);

static const std::set<std::string> CONTROL_TYPE_SET(
	CONTROL_TYPE_STR,
	CONTROL_TYPE_STR + MAX_CONTROL_TYPE + 1
	);

static const std::set<std::string> CONVERSION_OPERATOR_TYPE_SET(
	CONVERSION_OPERATOR_TYPE_STR,
	CONVERSION_OPERATOR_TYPE_STR + MAX_CONVERSION_OPERATOR_TYPE + 1
	);

static const std::set<std::string> FILE_STREAM_OPERATOR_TYPE_SET(
	FILE_STREAM_OPERATOR_TYPE_STR,
	FILE_STREAM_OPERATOR_TYPE_STR + MAX_FILE_STREAM_OPERATOR_TYPE + 1
	);

static const std::set<std::string> IO_OPERATOR_TYPE_SET(
	IO_OPERATOR_TYPE_STR,
	IO_OPERATOR_TYPE_STR + MAX_IO_OPERATOR_TYPE + 1
	);

static const std::set<std::string> IN_LIST_OPERATOR_TYPE_SET(
	IN_LIST_OPERATOR_TYPE_STR,
	IN_LIST_OPERATOR_TYPE_STR + MAX_IN_LIST_OPERATOR_TYPE + 1
	);

static const std::set<std::string> ITERATOR_OPERATOR_TYPE_SET(
	ITERATOR_OPERATOR_TYPE_STR,
	ITERATOR_OPERATOR_TYPE_STR + MAX_ITERATOR_OPERATOR_TYPE + 1
	);

static const std::set<std::string> LOGICAL_OPERATOR_TYPE_SET(
	LOGICAL_OPERATOR_TYPE_STR,
	LOGICAL_OPERATOR_TYPE_STR + MAX_LOGICAL_OPERATOR_TYPE + 1
	);

static const std::set<std::string> OUT_LIST_OPERATOR_TYPE_SET(
	OUT_LIST_OPERATOR_TYPE_STR,
	OUT_LIST_OPERATOR_TYPE_STR + MAX_OUT_LIST_OPERATOR_TYPE + 1
	);

static const std::set<std::string> STREAM_TYPE_SET(
	STREAM_TYPE_STR,
	STREAM_TYPE_STR + MAX_STREAM_TYPE + 1
	);

static const std::set<std::string> SYMBOL_TYPE_SET(
	SYMBOL_TYPE_STR,
	SYMBOL_TYPE_STR + MAX_SYMBOL_TYPE + 1
	);

static const std::set<std::string> USING_TYPE_SET(
	USING_TYPE_STR,
	USING_TYPE_STR + MAX_USING_TYPE + 1
	);

/*
 * Language characters
 */
#define SYMBOL_COMMENT '#'
#define SYMBOL_DECIMAL '.'
#define SYMBOL_STRING_DELIM '\''
#define SYMBOL_UNDERSCORE '_'

/*
 * Language global types
 */
#define NONE_TYPE "none"
#define UNKNOWN_TYPE "unknown type"
#define INVALID_TYPE ((size_t) -1)
#define UNREF_PARAM(_P_) ((void) _P_)

/*
 * Language string lookup macros
 */
#define ACCESS_TYPE_STRING(_T_) (_T_ > MAX_ACCESS_TYPE ? UNKNOWN_TYPE : ACCESS_TYPE_STR[_T_])
#define ARGUMENT_TYPE_STRING(_T_) (_T_ > MAX_ARGUMENT_TYPE ? UNKNOWN_TYPE : ARGUMENT_TYPE_STR[_T_])
#define ASSIGNMENT_TYPE_STRING(_T_) (_T_ > MAX_ASSIGNMENT_TYPE ? UNKNOWN_TYPE : ASSIGNMENT_TYPE_STR[_T_])
#define BINARY_OPERATOR_TYPE_STRING(_T_) (_T_ > MAX_BINARY_OPERATOR_TYPE ? UNKNOWN_TYPE : BINARY_OPERATOR_TYPE_STR[_T_])
#define CALL_TYPE_STRING(_T_) (_T_ > MAX_CALL_TYPE ? UNKNOWN_TYPE : CALL_TYPE_STR[_T_])
#define CLASS_TOK_TYPE_STRING(_T_) (_T_ > MAX_CLASS_TOK_TYPE ? "unknown class type" : CLASS_TOK_TYPE_STR[_T_])
#define COMPARATOR_TYPE_STRING(_T_) (_T_ > MAX_COMPARATOR_TYPE ? UNKNOWN_TYPE : COMPARATOR_TYPE_STR[_T_])
#define CONDITIONAL_SEPERATOR_TYPE_STRING(_T_) (_T_ > MAX_CONDITIONAL_SEPERATOR_TYPE ? UNKNOWN_TYPE : CONDITIONAL_SEPERATOR_TYPE_STR[_T_])
#define CONDITIONAL_TYPE_STRING(_T_) (_T_ > MAX_CONDITIONAL_TYPE ? UNKNOWN_TYPE : CONDITIONAL_TYPE_STR[_T_])
#define CONSTANT_TYPE_STRING(_T_) (_T_ > MAX_CONSTANT_TYPE ? UNKNOWN_TYPE : CONSTANT_TYPE_STR[_T_])
#define CONTROL_TYPE_STRING(_T_) (_T_ > MAX_CONTROL_TYPE ? UNKNOWN_TYPE : CONTROL_TYPE_STR[_T_])
#define CONVERSION_OPERATOR_TYPE_STRING(_T_) (_T_ > MAX_CONVERSION_OPERATOR_TYPE ? UNKNOWN_TYPE : CONVERSION_OPERATOR_TYPE_STR[_T_])
#define FILE_STREAM_OPERATOR_TYPE_STRING(_T_) (_T_ > MAX_FILE_STREAM_OPERATOR_TYPE ? UNKNOWN_TYPE : FILE_STREAM_OPERATOR_TYPE_STR[_T_])
#define IO_OPERATOR_TYPE_STRING(_T_) (_T_ > MAX_IO_OPERATOR_TYPE ? UNKNOWN_TYPE : IO_OPERATOR_TYPE_STR[_T_])
#define IN_LIST_OPERATOR_TYPE_STRING(_T_) (_T_ > MAX_IN_LIST_OPERATOR_TYPE ? UNKNOWN_TYPE : IN_LIST_OPERATOR_TYPE_STR[_T_])
#define ITERATOR_OPERATOR_TYPE_STRING(_T_) (_T_ > MAX_ITERATOR_OPERATOR_TYPE ? UNKNOWN_TYPE : ITERATOR_OPERATOR_TYPE_STR[_T_])
#define LOGICAL_OPERATOR_TYPE_STRING(_T_) (_T_ > MAX_LOGICAL_OPERATOR_TYPE ? UNKNOWN_TYPE : LOGICAL_OPERATOR_TYPE_STR[_T_])
#define OUT_LIST_OPERATOR_TYPE_STRING(_T_) (_T_ > MAX_OUT_LIST_OPERATOR_TYPE ? UNKNOWN_TYPE : OUT_LIST_OPERATOR_TYPE_STR[_T_])
#define STREAM_TYPE_STRING(_T_) (_T_ > MAX_STREAM_TYPE ? UNKNOWN_TYPE : STREAM_TYPE_STR[_T_])
#define SYMBOL_TYPE_STRING(_T_) (_T_ > MAX_SYMBOL_TYPE ? UNKNOWN_TYPE : SYMBOL_TYPE_STR[_T_])
#define USING_TYPE_STRING(_T_) (_T_ > MAX_USING_TYPE ? UNKNOWN_TYPE : USING_TYPE_STR[_T_])
#define TOKEN_SUBTYPE_STRING(_T_, _ST_)\
	(_T_ > MAX_LOOKUP_TYPE ? UNKNOWN_TYPE : (_ST_ > TYPE_COUNT_LOOKUP[_T_] ? NONE_TYPE : (TYPE_STRING_LOOKUP[_T_] == NULL ? NONE_TYPE : TYPE_STRING_LOOKUP[_T_][_ST_])))
#define TOKEN_TYPE_STRING(_T_) (_T_ > MAX_TOKEN_TYPE ? UNKNOWN_TYPE : TOKEN_TYPE_STR[_T_])

/*
 * Language type macros
 */
#define IS_ACCESS_TYPE(_S_) (ACCESS_TYPE_SET.find(_S_) != ACCESS_TYPE_SET.end())
#define IS_ARGUMENT_TYPE(_S_) (ARGUMENT_TYPE_SET.find(_S_) != ARGUMENT_TYPE_SET.end())
#define IS_ASSIGNMENT_TYPE(_S_) (ASSIGNMENT_TYPE_SET.find(_S_) != ASSIGNMENT_TYPE_SET.end())
#define IS_BINARY_OPERATOR_TYPE(_S_) (BINARY_OPERATOR_TYPE_SET.find(_S_) != BINARY_OPERATOR_TYPE_SET.end())
#define IS_CALL_TYPE(_S_) (CALL_TYPE_SET.find(_S_) != CALL_TYPE_SET.end())
#define IS_COMPARATOR_TYPE(_S_) (COMPARATOR_TYPE_SET.find(_S_) != COMPARATOR_TYPE_SET.end())
#define IS_CONDITIONAL_SEPERATOR_TYPE(_S_) (CONDITIONAL_SEPERATOR_TYPE_SET.find(_S_) != CONDITIONAL_SEPERATOR_TYPE_SET.end())
#define IS_CONDITIONAL_TYPE(_S_) (CONDITIONAL_TYPE_SET.find(_S_) != CONDITIONAL_TYPE_SET.end())
#define IS_CONSTANT_TYPE(_S_) (CONSTANT_TYPE_SET.find(_S_) != CONSTANT_TYPE_SET.end())
#define IS_CONTROL_TYPE(_S_) (CONTROL_TYPE_SET.find(_S_) != CONTROL_TYPE_SET.end())
#define IS_CONVERSION_OPERATOR_TYPE(_S_) (CONVERSION_OPERATOR_TYPE_SET.find(_S_) != CONVERSION_OPERATOR_TYPE_SET.end())
#define IS_FILE_STREAM_OPERATOR_TYPE(_S_) (FILE_STREAM_OPERATOR_TYPE_SET.find(_S_) != FILE_STREAM_OPERATOR_TYPE_SET.end())
#define IS_IO_OPERATOR_TYPE(_S_) (IO_OPERATOR_TYPE_SET.find(_S_) != IO_OPERATOR_TYPE_SET.end())
#define IS_IN_LIST_OPERATOR_TYPE(_S_) (IN_LIST_OPERATOR_TYPE_SET.find(_S_) != IN_LIST_OPERATOR_TYPE_SET.end())
#define IS_ITERATOR_OPERATOR_TYPE(_S_) (ITERATOR_OPERATOR_TYPE_SET.find(_S_) != ITERATOR_OPERATOR_TYPE_SET.end())
#define IS_LOGICAL_OPERATOR_TYPE(_S_) (LOGICAL_OPERATOR_TYPE_SET.find(_S_) != LOGICAL_OPERATOR_TYPE_SET.end())
#define IS_OUT_LIST_OPERATOR_TYPE(_S_) (OUT_LIST_OPERATOR_TYPE_SET.find(_S_) != OUT_LIST_OPERATOR_TYPE_SET.end())
#define IS_STREAM_TYPE(_S_) (STREAM_TYPE_SET.find(_S_) != STREAM_TYPE_SET.end())
#define IS_SYMBOL_TYPE(_S_) (SYMBOL_TYPE_SET.find(_S_) != SYMBOL_TYPE_SET.end())
#define IS_USING_TYPE(_S_) (USING_TYPE_SET.find(_S_) != USING_TYPE_SET.end())

/*
 * Find language subtype
 * @param text token string reference
 * @param type token type
 * @return token subtype, or INVALID_TYPE
 */
extern size_t lang_find_subtype(
	const std::string &text,
	size_t type
	);

#endif